<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TN Sudoku Generator</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --ink: #1c1510;
  --paper: #f7f3ec;
  --cream: #ede8dc;
  --warm-white: #fdfaf5;
  --accent: #8b3a1a;
  --accent-light: #b85c34;
  --accent-pale: #f5ece7;
  --rule: #d4cbbf;
  --rule-light: #e8e2d8;
  --muted: #9a9080;
  --green: #2d6a4f;
  --green-pale: #eaf4ee;
  --shadow-sm: 0 1px 3px rgba(28,21,16,0.08);
  --shadow-md: 0 4px 16px rgba(28,21,16,0.1);
  --shadow-lg: 0 8px 32px rgba(28,21,16,0.12);
}

html { font-size: 15px; }

body {
  background: var(--paper);
  color: var(--ink);
  font-family: 'DM Mono', monospace;
  min-height: 100vh;
  display: grid;
  grid-template-rows: auto 1fr auto;
  grid-template-columns: 1fr;
}

/* ── Header ── */
header {
  padding: 28px 48px;
  border-bottom: 1px solid var(--rule);
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: var(--warm-white);
  position: sticky;
  top: 0;
  z-index: 10;
  box-shadow: var(--shadow-sm);
}

.logo {
  font-family: 'Playfair Display', serif;
  font-size: 1.5rem;
  line-height: 1;
  letter-spacing: -0.01em;
}

.logo em { font-style: italic; color: var(--accent); }

.header-tag {
  font-size: 0.6rem;
  letter-spacing: 0.18em;
  text-transform: uppercase;
  color: var(--muted);
  border: 1px solid var(--rule);
  padding: 4px 10px;
  border-radius: 2px;
}

/* ── Main layout ── */
main {
  display: grid;
  grid-template-columns: 400px 1fr;
  min-height: calc(100vh - 117px);
}

/* ── Left panel: settings ── */
.settings-panel {
  border-right: 1px solid var(--rule);
  background: var(--warm-white);
  overflow-y: auto;
  display: flex;
  flex-direction: column;
}

.settings-inner {
  padding: 32px 28px;
  flex: 1;
}

.section {
  margin-bottom: 32px;
}

.section-title {
  font-size: 0.6rem;
  letter-spacing: 0.2em;
  text-transform: uppercase;
  color: var(--muted);
  margin-bottom: 14px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--rule-light);
}

/* Radio groups */
.radio-group {
  display: grid;
  gap: 6px;
}

.radio-group.cols-2 { grid-template-columns: 1fr 1fr; }
.radio-group.cols-3 { grid-template-columns: 1fr 1fr 1fr; }

.radio-option input { display: none; }

.radio-btn {
  display: block;
  padding: 10px 12px;
  border: 1.5px solid var(--rule);
  border-radius: 3px;
  background: var(--cream);
  cursor: pointer;
  transition: all 0.12s ease;
  font-family: 'DM Mono', monospace;
  font-size: 0.72rem;
  line-height: 1.4;
  color: var(--ink);
}

.radio-btn .rb-title {
  display: block;
  font-size: 0.78rem;
  font-weight: 500;
  margin-bottom: 1px;
  color: var(--ink);
}

.radio-btn .rb-sub {
  display: block;
  font-size: 0.62rem;
  color: var(--muted);
}

.radio-option input:checked + .radio-btn {
  border-color: var(--accent);
  background: var(--accent-pale);
  color: var(--accent);
}

.radio-option input:checked + .radio-btn .rb-title { color: var(--accent); }
.radio-option input:checked + .radio-btn .rb-sub { color: var(--accent-light); opacity: 0.7; }

.radio-btn:hover { border-color: var(--accent-light); }

/* Text input */
.text-input {
  width: 100%;
  font-family: 'DM Mono', monospace;
  font-size: 0.78rem;
  color: var(--ink);
  border: 1.5px solid var(--rule);
  border-radius: 3px;
  background: var(--cream);
  padding: 10px 12px;
  outline: none;
  transition: border-color 0.12s;
}
.text-input:focus { border-color: var(--accent); }
.text-input::placeholder { color: var(--muted); }

/* Page count */
.count-row {
  display: flex;
  align-items: center;
  gap: 10px;
}

.count-btn {
  width: 34px;
  height: 34px;
  border: 1.5px solid var(--rule);
  background: var(--cream);
  color: var(--ink);
  font-size: 1.1rem;
  cursor: pointer;
  border-radius: 3px;
  transition: all 0.12s;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  font-family: 'DM Mono', monospace;
}

.count-btn:hover { border-color: var(--accent); background: var(--accent); color: white; }

.count-input {
  font-family: 'Playfair Display', serif;
  font-size: 1.6rem;
  width: 64px;
  text-align: center;
  border: 1.5px solid var(--rule);
  border-radius: 3px;
  background: var(--cream);
  padding: 4px;
  color: var(--ink);
  outline: none;
  -moz-appearance: textfield;
}
.count-input:focus { border-color: var(--accent); }
.count-input::-webkit-inner-spin-button,
.count-input::-webkit-outer-spin-button { -webkit-appearance: none; }

.count-hint {
  font-size: 0.62rem;
  color: var(--muted);
}

/* Duplex banner */
.duplex-banner {
  padding: 9px 12px;
  border-radius: 3px;
  font-size: 0.65rem;
  line-height: 1.5;
  border: 1.5px solid;
  display: flex;
  align-items: flex-start;
  gap: 8px;
}
.duplex-banner.manual { background: #fef9f0; border-color: #d4a017; color: #7a5a00; }
.duplex-banner.supported { background: var(--green-pale); border-color: var(--green); color: var(--green); }
.duplex-banner .icon { flex-shrink: 0; }

/* Generate button */
.generate-btn {
  width: 100%;
  padding: 15px;
  background: var(--accent);
  color: var(--paper);
  border: none;
  border-radius: 3px;
  font-family: 'DM Mono', monospace;
  font-size: 0.75rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.15s;
  box-shadow: 0 2px 8px rgba(139,58,26,0.25);
}
.generate-btn:hover:not(:disabled) {
  background: var(--accent-light);
  box-shadow: 0 4px 16px rgba(139,58,26,0.3);
  transform: translateY(-1px);
}
.generate-btn:disabled { opacity: 0.55; cursor: not-allowed; transform: none; }

/* Progress */
.progress { display: none; margin-top: 12px; }
.progress.visible { display: block; }
.progress-track { height: 3px; background: var(--cream); border-radius: 2px; overflow: hidden; margin-bottom: 6px; }
.progress-fill { height: 100%; background: var(--accent); border-radius: 2px; transition: width 0.3s ease; width: 0%; }
.progress-text { font-size: 0.6rem; color: var(--muted); letter-spacing: 0.06em; }

.settings-footer {
  padding: 20px 28px;
  border-top: 1px solid var(--rule-light);
  background: var(--warm-white);
}

/* ── Right panel: preview ── */
.preview-panel {
  background: var(--cream);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding: 40px;
  position: relative;
  overflow: hidden;
}

.preview-panel::before {
  content: '';
  position: absolute;
  inset: 0;
  background-image:
    radial-gradient(circle at 20px 20px, var(--rule-light) 1px, transparent 1px);
  background-size: 28px 28px;
  opacity: 0.6;
  pointer-events: none;
}

.preview-header {
  width: 100%;
  max-width: 640px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 20px;
  position: relative;
  z-index: 1;
}

.preview-label {
  font-size: 0.6rem;
  letter-spacing: 0.2em;
  text-transform: uppercase;
  color: var(--muted);
}

.preview-badge {
  font-size: 0.58rem;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  padding: 3px 8px;
  border: 1px solid var(--rule);
  border-radius: 2px;
  color: var(--muted);
  background: var(--warm-white);
}

.preview-sheet {
  width: 100%;
  max-width: 640px;
  position: relative;
  z-index: 1;
  background: white;
  border-radius: 2px;
  box-shadow: var(--shadow-lg), 0 0 0 1px var(--rule);
  overflow: hidden;
  aspect-ratio: 297 / 210;
  min-height: 180px;
}

.preview-sheet canvas {
  width: 100%;
  height: 100%;
  display: block;
}

.preview-info {
  margin-top: 20px;
  display: flex;
  gap: 24px;
  position: relative;
  z-index: 1;
  flex-wrap: wrap;
  justify-content: center;
}

.preview-stat {
  text-align: center;
}

.preview-stat-val {
  font-family: 'Playfair Display', serif;
  font-size: 1.5rem;
  color: var(--accent);
  display: block;
  line-height: 1;
  margin-bottom: 3px;
}

.preview-stat-label {
  font-size: 0.58rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--muted);
}

/* ── Modal ── */
.modal-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(28,21,16,0.6);
  z-index: 100;
  align-items: center;
  justify-content: center;
  padding: 24px;
  backdrop-filter: blur(4px);
}
.modal-overlay.visible { display: flex; }

.modal {
  background: var(--warm-white);
  border: 1px solid var(--rule);
  border-radius: 4px;
  padding: 36px;
  max-width: 420px;
  width: 100%;
  box-shadow: var(--shadow-lg);
}

.modal-title {
  font-family: 'Playfair Display', serif;
  font-size: 1.3rem;
  margin-bottom: 4px;
  color: var(--ink);
}

.modal-sub {
  font-size: 0.6rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--muted);
  margin-bottom: 24px;
}

.step {
  display: flex;
  gap: 14px;
  margin-bottom: 18px;
  align-items: flex-start;
}

.step-num {
  width: 26px; height: 26px;
  border-radius: 50%;
  background: var(--accent);
  color: white;
  font-size: 0.65rem;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  margin-top: 1px;
  transition: background 0.2s;
}

.step-num.done { background: var(--green); }

.step-text {
  font-size: 0.72rem;
  line-height: 1.55;
  color: var(--ink);
}

.step-text strong { color: var(--accent); }

.modal-actions { display: flex; gap: 10px; margin-top: 28px; flex-wrap: wrap; }

.modal-btn {
  padding: 11px 20px;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 3px;
  font-family: 'DM Mono', monospace;
  font-size: 0.7rem;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.12s;
}
.modal-btn:hover:not(:disabled) { background: var(--accent-light); }
.modal-btn:disabled { opacity: 0.5; cursor: not-allowed; }

.modal-btn.ghost {
  background: transparent;
  color: var(--muted);
  border: 1.5px solid var(--rule);
}
.modal-btn.ghost:hover { border-color: var(--accent); color: var(--accent); background: transparent; }

/* ── Responsive ── */
@media (max-width: 860px) {
  main { grid-template-columns: 1fr; }
  .preview-panel { padding: 24px; }
  header { padding: 20px 24px; }
}
</style>
</head>
<body>
<div style="position:fixed;top:0;left:0;right:0;z-index:200;background:rgba(245,240,228,0.95);backdrop-filter:blur(8px);border-bottom:1px solid #c8bda0;padding:0 32px;height:44px;display:flex;align-items:center;justify-content:space-between;font-family:'DM Mono',monospace;">
  <a href="https://einarjonsson.github.io" style="font-size:0.62rem;letter-spacing:0.12em;text-transform:uppercase;color:#7a7060;text-decoration:none;display:flex;align-items:center;gap:8px;transition:color 0.15s;" onmouseover="this.style.color='#7a2e0e'" onmouseout="this.style.color='#7a7060'">
    ← The Insert Studio
  </a>
  <span style="font-size:0.58rem;letter-spacing:0.14em;text-transform:uppercase;color:#c8bda0;">Sudoku Generator</span>
</div>

<header>
  <div class="logo">Traveler's <em>Sudoku</em></div>
  <div class="header-tag">A4 Printable Inserts</div>
</header>

<main>
  <!-- ── Left: Settings ── -->
  <aside class="settings-panel">
    <div class="settings-inner">

      <!-- Notebook size -->
      <div class="section">
        <div class="section-title">Notebook Size</div>
        <div class="radio-group cols-2">
          <label class="radio-option">
            <input type="radio" name="size" value="regular" checked>
            <span class="radio-btn">
              <span class="rb-title">Regular</span>
              <span class="rb-sub">110mm · fold + cut</span>
            </span>
          </label>
          <label class="radio-option">
            <input type="radio" name="size" value="passport">
            <span class="radio-btn">
              <span class="rb-title">Passport</span>
              <span class="rb-sub">134×98mm · cut only</span>
            </span>
          </label>
        </div>
      </div>

      <!-- Difficulty -->
      <div class="section">
        <div class="section-title">Difficulty</div>
        <div class="radio-group cols-3">
          <label class="radio-option">
            <input type="radio" name="difficulty" value="easy">
            <span class="radio-btn">
              <span class="rb-title">Easy</span>
              <span class="rb-sub">36 removed</span>
            </span>
          </label>
          <label class="radio-option">
            <input type="radio" name="difficulty" value="medium" checked>
            <span class="radio-btn">
              <span class="rb-title">Medium</span>
              <span class="rb-sub">45 removed</span>
            </span>
          </label>
          <label class="radio-option">
            <input type="radio" name="difficulty" value="hard">
            <span class="radio-btn">
              <span class="rb-title">Hard</span>
              <span class="rb-sub">54 removed</span>
            </span>
          </label>
        </div>
      </div>

      <!-- Font -->
      <div class="section">
        <div class="section-title">Font Style</div>
        <div class="radio-group cols-3">
          <label class="radio-option">
            <input type="radio" name="font" value="helvetica" checked>
            <span class="radio-btn">
              <span class="rb-title" style="font-family:sans-serif">Classic</span>
              <span class="rb-sub">clean & minimal</span>
            </span>
          </label>
          <label class="radio-option">
            <input type="radio" name="font" value="times">
            <span class="radio-btn">
              <span class="rb-title" style="font-family:serif">Serif</span>
              <span class="rb-sub">newspaper style</span>
            </span>
          </label>
          <label class="radio-option">
            <input type="radio" name="font" value="courier">
            <span class="radio-btn">
              <span class="rb-title" style="font-family:monospace">Mono</span>
              <span class="rb-sub">typewriter style</span>
            </span>
          </label>
        </div>
      </div>

      <!-- Numbering -->
      <div class="section">
        <div class="section-title">Puzzle Numbering</div>
        <div class="radio-group cols-3">
          <label class="radio-option">
            <input type="radio" name="numbering" value="sudoku" checked>
            <span class="radio-btn">
              <span class="rb-title">Sudoku 1</span>
              <span class="rb-sub">default</span>
            </span>
          </label>
          <label class="radio-option">
            <input type="radio" name="numbering" value="no">
            <span class="radio-btn">
              <span class="rb-title">No. 1</span>
              <span class="rb-sub">classic</span>
            </span>
          </label>
          <label class="radio-option">
            <input type="radio" name="numbering" value="roman">
            <span class="radio-btn">
              <span class="rb-title">I, II, III</span>
              <span class="rb-sub">roman</span>
            </span>
          </label>
        </div>
      </div>

      <!-- Personalisation -->
      <div class="section">
        <div class="section-title">Personalisation</div>
        <div style="display:flex;flex-direction:column;gap:10px;">
          <input type="text" id="customTitle" class="text-input" placeholder="Custom title (e.g. Anna's Sudoku Book)">

          <div class="radio-group cols-2">
            <label class="radio-option">
              <input type="radio" name="cover" value="none" checked>
              <span class="radio-btn">
                <span class="rb-title">No Cover</span>
                <span class="rb-sub">puzzles only</span>
              </span>
            </label>
            <label class="radio-option">
              <input type="radio" name="cover" value="cover">
              <span class="radio-btn">
                <span class="rb-title">Cover Page</span>
                <span class="rb-sub">framed + title</span>
              </span>
            </label>
          </div>
        </div>
      </div>

      <!-- Extras -->
      <div class="section">
        <div class="section-title">Extras</div>
        <div class="radio-group cols-2" style="margin-bottom:10px;">
          <label class="radio-option">
            <input type="radio" name="notes" value="none" checked>
            <span class="radio-btn">
              <span class="rb-title">No Notes</span>
              <span class="rb-sub">puzzle only</span>
            </span>
          </label>
          <label class="radio-option">
            <input type="radio" name="notes" value="notes">
            <span class="radio-btn">
              <span class="rb-title">Notes</span>
              <span class="rb-sub">lined section</span>
            </span>
          </label>
        </div>
        <div class="radio-group cols-2">
          <label class="radio-option">
            <input type="radio" name="datefield" value="none" checked>
            <span class="radio-btn">
              <span class="rb-title">No Date</span>
              <span class="rb-sub">clean layout</span>
            </span>
          </label>
          <label class="radio-option">
            <input type="radio" name="datefield" value="date">
            <span class="radio-btn">
              <span class="rb-title">Date Field</span>
              <span class="rb-sub">Date: ____</span>
            </span>
          </label>
        </div>
      </div>

      <!-- Pages -->
      <div class="section">
        <div class="section-title">Number of Pages</div>
        <div class="count-row">
          <button class="count-btn" id="decBtn">−</button>
          <input type="number" id="countDisplay" class="count-input" value="1" min="1" max="999">
          <button class="count-btn" id="incBtn">+</button>
          <span class="count-hint" id="countHint">= 8 sudokus</span>
        </div>
      </div>

      <!-- Printer -->
      <div class="section">
        <div class="section-title">Printer</div>
        <div id="duplexBanner" class="duplex-banner manual">
          <span class="icon">⚠</span>
          <span id="duplexText">Couldn't confirm duplex support. Two PDFs will be generated — Side 1 first, then Side 2 after reinserting.<br><a href="#" id="duplexOverride" style="color:var(--accent);font-size:0.65rem;">My printer supports duplex →</a></span>
        </div>
      </div>

    </div>

    <!-- Generate -->
    <div class="settings-footer">
      <button class="generate-btn" id="generateBtn">Generate &amp; Download PDF</button>
      <div class="progress" id="progress">
        <div class="progress-track"><div class="progress-fill" id="progressFill"></div></div>
        <div class="progress-text" id="progressText">Generating puzzles...</div>
      </div>
    </div>
  </aside>

  <!-- ── Right: Preview ── -->
  <section class="preview-panel">
    <div class="preview-header">
      <span class="preview-label">Live Preview</span>
      <span class="preview-badge" id="previewBadge">Regular · Medium</span>
    </div>

    <div class="preview-sheet">
      <canvas id="previewCanvas"></canvas>
    </div>

    <div class="preview-info">
      <div class="preview-stat">
        <span class="preview-stat-val" id="statPuzzles">8</span>
        <span class="preview-stat-label">Sudokus</span>
      </div>
      <div class="preview-stat">
        <span class="preview-stat-val" id="statSheets">1</span>
        <span class="preview-stat-label">Sheets to Print</span>
      </div>
      <div class="preview-stat">
        <span class="preview-stat-val" id="statPages">2</span>
        <span class="preview-stat-label">PDF Pages</span>
      </div>
    </div>
  </section>
</main>

<!-- Manual duplex modal -->
<div class="modal-overlay" id="modalOverlay">
  <div class="modal">
    <div class="modal-title">Two-step printing</div>
    <div class="modal-sub" id="modalSubtitle">No automatic duplex detected</div>
    <div id="modalSteps"></div>
    <div class="modal-actions">
      <button class="modal-btn" id="modalBtn1">Download Side 1</button>
      <button class="modal-btn ghost" id="modalClose">Close</button>
    </div>
  </div>
</div>

<script>
const { jsPDF } = window.jspdf;

let pageCount = 1;
let duplexSupported = false;
let generatedPuzzles = null;
let generatedSize = null;
let generatedPages = null;
let generatedDifficulty = null;
let generatedTitle = null;

const countInput = document.getElementById('countDisplay');
const countHint = document.getElementById('countHint');
const decBtn = document.getElementById('decBtn');
const incBtn = document.getElementById('incBtn');
const generateBtn = document.getElementById('generateBtn');
const progress = document.getElementById('progress');
const progressFill = document.getElementById('progressFill');
const progressText = document.getElementById('progressText');
const duplexBanner = document.getElementById('duplexBanner');
const duplexText = document.getElementById('duplexText');
const modalOverlay = document.getElementById('modalOverlay');
const modalBtn1 = document.getElementById('modalBtn1');
const modalClose = document.getElementById('modalClose');

// ── Duplex: always manual by default, click to enable ────────────────────────
duplexSupported = false;
duplexBanner.addEventListener('click', e => {
  if (e.target.id === 'duplexOverride') {
    e.preventDefault();
    duplexSupported = true;
    duplexBanner.className = 'duplex-banner supported';
    duplexBanner.innerHTML = '<span class="icon">✓</span><span>Duplex enabled — one combined PDF will be generated.</span>';
  }
});


// ── Duplex detection ──────────────────────────────────────────────────────────

// ── UI helpers ────────────────────────────────────────────────────────────────
function getSize() { return document.querySelector('input[name="size"]:checked').value; }
function getDifficulty() { return document.querySelector('input[name="difficulty"]:checked')?.value || 'medium'; }
function getTitle() { return document.getElementById('customTitle')?.value.trim() || ''; }
function getCover() { return document.querySelector('input[name="cover"]:checked')?.value || 'none'; }
function getCoverTitle() { return getCover() === 'cover' ? getTitle() : null; }
function getFont() { return document.querySelector('input[name="font"]:checked')?.value || 'helvetica'; }
function getNotes() { return document.querySelector('input[name="notes"]:checked')?.value || 'none'; }
function getNumbering() { return document.querySelector('input[name="numbering"]:checked')?.value || 'sudoku'; }
function getDateField() { return document.querySelector('input[name="datefield"]:checked')?.value || 'none'; }
function toRoman(n) {
  const vals = [1000,900,500,400,100,90,50,40,10,9,5,4,1];
  const syms = ['M','CM','D','CD','C','XC','L','XL','X','IX','V','IV','I'];
  let result = '';
  for (let i = 0; i < vals.length; i++) { while (n >= vals[i]) { result += syms[i]; n -= vals[i]; } }
  return result;
}
function puzzleLabel(n) {
  const style = getNumbering();
  if (style === 'no') return `No. ${n}`;
  if (style === 'roman') return toRoman(n);
  return `Sudoku ${n}`;
}

function updateHint() {
  pageCount = parseInt(countInput.value) || 1;
  countHint.textContent = `= ${pageCount * 8} sudokus`;
}

document.querySelectorAll('input[name="size"]').forEach(r => r.addEventListener('change', updateHint));
countInput.addEventListener('input', updateHint);
decBtn.addEventListener('click', () => { if (pageCount > 1) { pageCount--; countInput.value = pageCount; updateHint(); } });
incBtn.addEventListener('click', () => { pageCount++; countInput.value = pageCount; updateHint(); });

// ── Sudoku logic ──────────────────────────────────────────────────────────────
function isValid(board, row, col, num) {
  for (let c = 0; c < 9; c++) if (board[row][c] === num) return false;
  for (let r = 0; r < 9; r++) if (board[r][col] === num) return false;
  const br = Math.floor(row/3)*3, bc = Math.floor(col/3)*3;
  for (let r = br; r < br+3; r++) for (let c = bc; c < bc+3; c++) if (board[r][c] === num) return false;
  return true;
}
function shuffle(arr) {
  for (let i = arr.length-1; i > 0; i--) { const j = Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
  return arr;
}
function solve(board) {
  for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) {
    if (board[r][c] === 0) {
      for (const n of shuffle([1,2,3,4,5,6,7,8,9])) {
        if (isValid(board,r,c,n)) { board[r][c]=n; if(solve(board)) return true; board[r][c]=0; }
      }
      return false;
    }
  }
  return true;
}
function generateSudoku(difficulty) {
  const removals = difficulty === "easy" ? 36 : difficulty === "hard" ? 54 : 45;
  const board = Array.from({length:9}, ()=>Array(9).fill(0));
  solve(board);
  const cells = []; for (let r=0;r<9;r++) for (let c=0;c<9;c++) cells.push([r,c]);
  shuffle(cells); for (const [r,c] of cells.slice(0, removals)) board[r][c]=0;
  return board;
}

// ── PDF drawing ───────────────────────────────────────────────────────────────
function drawSudoku(doc, ox, oy, size, puzzle, number, labelFs=3) {
  const cell = size/9;
  doc.setFontSize(labelFs*2.5); doc.setFont(getFont(),'bold'); doc.setTextColor(0,0,0);
  doc.setFillColor(255,255,255);
  const pLabel = puzzleLabel(number);
  doc.rect(ox, oy-labelFs*1.2, doc.getTextWidth(pLabel)+2, labelFs*1.5, 'F');
  doc.text(pLabel, ox+1, oy-labelFs*0.2);
  for (let row=0; row<9; row++) for (let col=0; col<9; col++) {
    const val = puzzle[row][col];
    if (val !== 0) {
      const x=ox+col*cell, y=oy+row*cell;
      doc.setFontSize(cell*1.8); doc.setFont(getFont(),'normal'); doc.setTextColor(0,0,0);
      const tw=doc.getTextWidth(String(val));
      doc.text(String(val), x+(cell-tw)/2, y+cell*0.72);
    }
  }
  doc.setDrawColor(0,0,0);
  for (let i=0; i<=9; i++) {
    doc.setLineWidth(i%3===0?0.5:0.18);
    doc.line(ox, oy+i*cell, ox+size, oy+i*cell);
    doc.line(ox+i*cell, oy, ox+i*cell, oy+size);
  }
}


function drawPageTitle(doc, title, W, H) {
  if (!title) return;
  doc.setFontSize(7);
  doc.setFont(getFont(), 'bold');
  doc.setTextColor(80, 80, 80);
  doc.text(title, W / 2, H - 4, { align: 'center' });
}

function drawCoverPage(doc, title) {
  const W = 297, H = 210;
  const colW = 110;

  // Left panel: blank (nothing drawn)

  // Right panel: frame with title
  const margin = 8;
  const fx = colW + margin, fy = margin;
  const fw = colW - margin*2, fh = H - margin*2;

  // Outer frame
  doc.setDrawColor(80, 80, 80);
  doc.setLineWidth(0.8);
  doc.rect(fx, fy, fw, fh);

  // Inner frame (inset by 3mm)
  doc.setLineWidth(0.25);
  doc.rect(fx + 3, fy + 3, fw - 6, fh - 6);

  // Corner marks
  const cs = 5; // corner mark size
  doc.setLineWidth(0.5);
  for (const [ox, oy, sx, sy] of [
    [fx+3, fy+3, 1, 1], [fx+fw-3, fy+3, -1, 1],
    [fx+3, fy+fh-3, 1, -1], [fx+fw-3, fy+fh-3, -1, -1]
  ]) {
    doc.line(ox, oy, ox + sx*cs, oy);
    doc.line(ox, oy, ox, oy + sy*cs);
  }

  if (title) {
    // Parse Vol. number from title if present, else just show title
    const centerX = fx + fw/2;
    const centerY = fy + fh/2;

    // Main title
    doc.setFont(getFont(), 'bold');
    doc.setTextColor(30, 30, 30);
    doc.setFontSize(11);
    doc.text(title, centerX, centerY - 4, { align: 'center', maxWidth: fw - 16 });

    // Decorative line under title
    const lineW = Math.min(doc.getTextWidth(title) + 8, fw - 20);
    doc.setLineWidth(0.3);
    doc.setDrawColor(120, 120, 120);
    doc.line(centerX - lineW/2, centerY + 1, centerX + lineW/2, centerY + 1);

    // "Sudoku Puzzles" subtitle
    doc.setFont(getFont(), 'normal');
    doc.setFontSize(6);
    doc.setTextColor(100, 100, 100);
    doc.text('SUDOKU PUZZLES', centerX, centerY + 7, { align: 'center' });
  } else {
    // Blank — show subtle writing lines
    const centerY = fy + fh/2;
    doc.setDrawColor(180, 180, 180);
    doc.setLineWidth(0.2);
    for (let i = -1; i <= 1; i++) {
      const ly = centerY + i * 8;
      doc.line(fx + 12, ly, fx + fw - 12, ly);
    }
    // Tiny label above lines
    doc.setFont(getFont(), 'normal');
    doc.setFontSize(5);
    doc.setTextColor(160, 160, 160);
    doc.text('MY SUDOKU BOOK', fx + fw/2, centerY - 14, { align: 'center' });
  }
}

function drawNotes(doc, ox, oy, width) {
  const lineGap = 4.5;
  const labelFs = 2.8;

  // Date field on the right if enabled
  if (getDateField() === 'date') {
    doc.setFont(getFont(), 'normal');
    doc.setFontSize(labelFs * 2.2);
    doc.setTextColor(160, 160, 160);
    const dateLabel = 'Date: ___________';
    const dw = doc.getTextWidth(dateLabel);
    doc.text(dateLabel, ox + width - dw, oy + labelFs);
  }

  // Notes label on the left
  doc.setFont(getFont(), 'normal');
  doc.setFontSize(labelFs * 2.2);
  doc.setTextColor(160, 160, 160);
  doc.text('Notes', ox, oy + labelFs);

  // Ruled lines
  doc.setDrawColor(180, 180, 180);
  doc.setLineWidth(0.15);
  for (let i = 0; i < 3; i++) {
    const ly = oy + labelFs + 2 + i * lineGap;
    doc.line(ox, ly, ox + width, ly);
  }
}

function drawRegularSide(doc, puzzles, startIdx, sideLabel) {
  const W=297, H=210, colW=110, margin=5, halfH=H/2;
  const notesH = getNotes() === 'notes' ? 18 : 0;
  const sudSize=Math.min(colW-2*margin, halfH-14-notesH), vGap=(halfH-sudSize-notesH)/2;
  for (const [col,row,num] of [[0,0,startIdx],[0,1,startIdx+1],[1,0,startIdx+2],[1,1,startIdx+3]]) {
    const ox = col*colW+margin, oy = row*halfH+vGap;
    drawSudoku(doc, ox, oy, sudSize, puzzles[num-1], num, 3);
    if (getNotes() === 'notes') drawNotes(doc, ox, oy + sudSize + 3, sudSize);
  }
  doc.setDrawColor(100,100,100); doc.setLineWidth(0.25);
  doc.setLineDashPattern([2,1.5],0); doc.line(colW,0,colW,H);
  doc.setLineDashPattern([0.8,2],0); doc.setDrawColor(80,80,80); doc.line(2*colW,0,2*colW,H);
  doc.setLineDashPattern([],0);
  doc.setDrawColor(180,180,180); doc.setLineWidth(0.12); doc.setLineDashPattern([1,2],0);
  doc.line(0,halfH,2*colW,halfH); doc.setLineDashPattern([],0);
  doc.setFontSize(4); doc.setFont(getFont(),'normal'); doc.setTextColor(120,120,120);
  doc.text('--- fold at 110mm', 2*colW+2, halfH-4);
  doc.text('... cut at 220mm', 2*colW+2, halfH);
  doc.text(sideLabel, 2*colW+2, halfH+4);
  drawPageTitle(doc, getTitle(), W, H);
}

function drawPassportSide(doc, puzzles, startIdx, sideLabel) {
  const W=297, H=210, pw=134, ph=98;
  const totalW=pw*2, totalH=ph*2;
  const startX=(W-totalW)/2, startY=(H-totalH)/2;
  const passNotesH = getNotes() === 'notes' ? 14 : 0;
  const labelH=8, gridSize=Math.min(pw-8,ph-8-labelH-passNotesH);
  const vOff=(ph-gridSize-labelH-passNotesH)/2, hOff=(pw-gridSize)/2;
  for (const [col,row,num] of [[0,0,startIdx],[1,0,startIdx+1],[0,1,startIdx+2],[1,1,startIdx+3]]) {
    const ox = startX+col*pw+hOff, oy = startY+row*ph+vOff;
    drawSudoku(doc, ox, oy, gridSize, puzzles[num-1], num, 2.5);
    if (getNotes() === 'notes') drawNotes(doc, ox, oy + gridSize + 2, gridSize);
  }
  doc.setDrawColor(160,160,160); doc.setLineWidth(0.15); doc.setLineDashPattern([],0);
  for (let col=0;col<2;col++) for (let row=0;row<2;row++) doc.rect(startX+col*pw, startY+row*ph, pw, ph);
  doc.setDrawColor(80,80,80); doc.setLineWidth(0.25); doc.setLineDashPattern([0.8,2],0);
  doc.line(startX+pw, startY-4, startX+pw, startY+totalH+4);
  doc.line(startX-4, startY+ph, startX+totalW+4, startY+ph);
  doc.setLineDashPattern([],0);
  doc.setFontSize(4); doc.setFont(getFont(),'normal'); doc.setTextColor(120,120,120);
  doc.text('... cut horizontally and vertically at centre | '+sideLabel, W/2, startY-4, {align:'center'});
  drawPageTitle(doc, getTitle(), W, H);
}

// ── Build PDFs ────────────────────────────────────────────────────────────────
function buildDoc(puzzles, size, pages, sideFilter) {
  // sideFilter: 'all' | 'side1' | 'side2'
  // For side2 manual duplex: pages must be in REVERSE order so when
  // the stack is flipped, page N back aligns with page N front.
  const doc = new jsPDF({ orientation:'landscape', unit:'mm', format:'a4' });
  let first = true;

  // Dedicated cover sheet: blank left panel, framed right panel
  // Printed as first page of side1 so when folded = outside front cover
  if (getCover() === 'cover' && sideFilter !== 'side2') {
    drawCoverPage(doc, getTitle());
    first = false;
  }

  const pageOrder = sideFilter === 'side2'
    ? Array.from({length:pages}, (_,i) => pages-1-i)  // reversed
    : Array.from({length:pages}, (_,i) => i);

  for (const p of pageOrder) {
    const base = p * 8;
    if (sideFilter === 'all' || sideFilter === 'side1') {
      if (!first) doc.addPage(); first = false;
      const label = `Page ${p+1} of ${pages} - Side 1`;
      size === 'regular'
        ? drawRegularSide(doc, puzzles, base+1, label)
        : drawPassportSide(doc, puzzles, base+1, label);
    }
    if (sideFilter === 'all' || sideFilter === 'side2') {
      if (!first) doc.addPage(); first = false;
      const label = `Page ${p+1} of ${pages} - Side 2`;
      size === 'regular'
        ? drawRegularSide(doc, puzzles, base+5, label)
        : drawPassportSide(doc, puzzles, base+5, label);
    }
  }
  return doc;
}

// ── Generate button ───────────────────────────────────────────────────────────
generateBtn.addEventListener('click', async () => {
  const size = getSize();
  const pages = parseInt(countInput.value) || 1;
  const total = pages * 8;

  generateBtn.disabled = true;
  progress.classList.add('visible');

  await new Promise(r => setTimeout(r, 50));

  const puzzles = [];
  for (let i=0; i<total; i++) {
    setProgress(i/total*60, `Generating puzzle ${i+1} of ${total}...`);
    await new Promise(r => setTimeout(r, 0));
    puzzles.push(generateSudoku(getDifficulty()));
  }

  setProgress(80, 'Building PDF...');
  await new Promise(r => setTimeout(r, 50));

  if (duplexSupported) {
    // Single PDF, all pages interleaved
    const doc = buildDoc(puzzles, size, pages, 'all');
    setProgress(100, 'Done! Downloading...');
    await new Promise(r => setTimeout(r, 300));
    const titleSlug = getTitle().replace(/[^a-z0-9]/gi,'-').toLowerCase().replace(/-+/g,'-').replace(/^-|-$/g,'');
    const fname = titleSlug ? `${titleSlug}-sudoku-${size}-${getDifficulty()}-${pages}pages.pdf` : `tn-sudoku-${size}-${getDifficulty()}-${pages}pages.pdf`;
    doc.save(fname);
    generateBtn.disabled = false;
    progress.classList.remove('visible');
    progressFill.style.width = '0%';
  } else {
    // Store puzzles and show modal
    generatedPuzzles = puzzles;
    generatedSize = size;
    generatedPages = pages;
    generatedDifficulty = getDifficulty();
    generatedTitle = getTitle();
    setProgress(100, 'Ready!');
    await new Promise(r => setTimeout(r, 300));
    generateBtn.disabled = false;
    progress.classList.remove('visible');
    progressFill.style.width = '0%';
    showManualModal(size, pages);
  }
});

// ── Manual duplex modal ───────────────────────────────────────────────────────
function showManualModal(size, pages) {
  document.getElementById('modalSteps').innerHTML = `
    <div class="step">
      <div class="step-num">1</div>
      <div class="step-text">Click <strong>Download Side 1</strong> and print it on your printer. Make sure to print in <strong>landscape</strong> orientation.</div>
    </div>
    <div class="step">
      <div class="step-num">2</div>
      <div class="step-text">Take the printed pages out of the tray. <strong>Flip the stack face-down</strong> and reinsert it into the paper feed — do not rotate it.</div>
    </div>
    <div class="step">
      <div class="step-num">3</div>
      <div class="step-text">Click <strong>Download Side 2</strong> and print it. The pages are already in reverse order so they line up correctly when flipped.</div>
    </div>
  `;

  modalBtn1.textContent = 'Download Side 1';
  modalBtn1.onclick = () => {
    const doc = buildDoc(generatedPuzzles, generatedSize, generatedPages, 'side1');
    doc.save(`tn-sudoku-${generatedSize}-${generatedDifficulty}-side1.pdf`);
    // After download, update modal to step 2/3
    modalBtn1.textContent = 'Download Side 2';
    modalBtn1.onclick = () => {
      const doc2 = buildDoc(generatedPuzzles, generatedSize, generatedPages, 'side2');
      doc2.save(`tn-sudoku-${generatedSize}-${generatedDifficulty}-side2.pdf`);
      modalBtn1.textContent = '✓ All done!';
      modalBtn1.disabled = true;
      // Mark steps done
      document.querySelectorAll('.step-num').forEach(el => { el.classList.add('done'); el.textContent = '✓'; });
    };
    // Mark step 1 done
    const steps = document.querySelectorAll('.step-num');
    steps[0].classList.add('done'); steps[0].textContent = '✓';
  };

  modalOverlay.classList.add('visible');
}

modalClose.addEventListener('click', () => modalOverlay.classList.remove('visible'));
modalOverlay.addEventListener('click', e => { if (e.target === modalOverlay) modalOverlay.classList.remove('visible'); });

function setProgress(pct, text) {
  progressFill.style.width = pct+'%';
  progressText.textContent = text;
}

updateHint();

// ── Live preview ──────────────────────────────────────────────────────────────
function updatePreview() {
  const size = getSize();
  const diff = getDifficulty();
  const pages = parseInt(document.getElementById('countDisplay').value) || 1;
  const hasCover = getCover() === 'cover';

  // Update badge and stats
  document.getElementById('previewBadge').textContent =
    `${size.charAt(0).toUpperCase()+size.slice(1)} · ${diff.charAt(0).toUpperCase()+diff.slice(1)}`;
  document.getElementById('statPuzzles').textContent = pages * 8;
  document.getElementById('statSheets').textContent = pages + (hasCover ? 1 : 0);
  document.getElementById('statPages').textContent = (pages + (hasCover ? 1 : 0)) * 2;

  // Draw preview on canvas
  const canvas = document.getElementById('previewCanvas');
  const rect = canvas.parentElement.getBoundingClientRect();
  const W = rect.width, H = rect.height;
  if (!W || !H) { setTimeout(updatePreview, 150); return; }
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  canvas.width = Math.round(W * window.devicePixelRatio);
  canvas.height = Math.round(H * window.devicePixelRatio);
  const ctx = canvas.getContext('2d');
  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

  // Scale: 297mm -> W px
  const scale = W / 297;

  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, W, H);

  if (size === 'regular') {
    drawRegularPreview(ctx, W, H, scale);
  } else {
    drawPassportPreview(ctx, W, H, scale);
  }
}

function drawRegularPreview(ctx, W, H, scale) {
  const colW = 110 * scale, halfH = H / 2, margin = 5 * scale;
  const sudSize = Math.min(colW - 2*margin, halfH - 14*scale);
  const vGap = (halfH - sudSize) / 2;
  const hasNotes = getNotes() === 'notes';
  const notesH = hasNotes ? 18*scale : 0;
  const actualSud = Math.min(colW - 2*margin, halfH - 14*scale - notesH);
  const actualVGap = (halfH - actualSud - notesH) / 2;

  // Draw 4 puzzle placeholders
  for (const [col, row] of [[0,0],[0,1],[1,0],[1,1]]) {
    const ox = col*colW + margin;
    const oy = row*halfH + actualVGap;
    drawPreviewGrid(ctx, ox, oy, actualSud, scale);
    if (hasNotes) drawPreviewNotes(ctx, ox, oy + actualSud + 2*scale, actualSud, scale);
  }

  // Fold line
  ctx.strokeStyle = 'rgba(100,100,100,0.5)';
  ctx.lineWidth = 0.8;
  ctx.setLineDash([6, 4]);
  ctx.beginPath(); ctx.moveTo(colW, 0); ctx.lineTo(colW, H); ctx.stroke();

  // Cut line
  ctx.setLineDash([2, 4]);
  ctx.strokeStyle = 'rgba(80,80,80,0.5)';
  ctx.beginPath(); ctx.moveTo(2*colW, 0); ctx.lineTo(2*colW, H); ctx.stroke();

  // Horizontal guide
  ctx.setLineDash([3, 5]);
  ctx.strokeStyle = 'rgba(180,180,180,0.6)';
  ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.moveTo(0, H/2); ctx.lineTo(2*colW, H/2); ctx.stroke();
  ctx.setLineDash([]);

  // Waste strip hatching
  ctx.fillStyle = 'rgba(220,215,208,0.4)';
  ctx.fillRect(2*colW, 0, W - 2*colW, H);

  // Labels
  ctx.font = `${4.5*scale}px DM Mono, monospace`;
  ctx.fillStyle = 'rgba(120,120,120,0.8)';
  ctx.fillText('fold', colW + 2*scale, H/2 - 8*scale);
  ctx.fillText('cut', 2*colW + 2*scale, H/2 - 8*scale);
  ctx.fillText('waste', 2*colW + 4*scale, H/2);
}

function drawPassportPreview(ctx, W, H, scale) {
  const pw = 134*scale, ph = 98*scale;
  const totalW = pw*2, totalH = ph*2;
  const startX = (W - totalW)/2, startY = (H - totalH)/2;
  const hasNotes = getNotes() === 'notes';
  const notesH = hasNotes ? 14*scale : 0;
  const labelH = 8*scale;
  const gridSize = Math.min(pw - 8*scale, ph - 8*scale - labelH - notesH);
  const vOff = (ph - gridSize - labelH - notesH)/2;
  const hOff = (pw - gridSize)/2;

  for (const [col, row] of [[0,0],[1,0],[0,1],[1,1]]) {
    const ox = startX + col*pw + hOff;
    const oy = startY + row*ph + vOff;
    // Panel bg
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(startX + col*pw, startY + row*ph, pw, ph);
    ctx.strokeStyle = 'rgba(160,160,160,0.4)';
    ctx.lineWidth = 0.5;
    ctx.strokeRect(startX + col*pw, startY + row*ph, pw, ph);
    drawPreviewGrid(ctx, ox, oy, gridSize, scale);
    if (hasNotes) drawPreviewNotes(ctx, ox, oy + gridSize + 2*scale, gridSize, scale);
  }

  // Cut lines
  ctx.strokeStyle = 'rgba(80,80,80,0.5)';
  ctx.lineWidth = 0.8;
  ctx.setLineDash([2, 4]);
  ctx.beginPath(); ctx.moveTo(startX+pw, startY-4*scale); ctx.lineTo(startX+pw, startY+totalH+4*scale); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(startX-4*scale, startY+ph); ctx.lineTo(startX+totalW+4*scale, startY+ph); ctx.stroke();
  ctx.setLineDash([]);

  // Background outside panels
  ctx.fillStyle = 'rgba(220,215,208,0.3)';
  ctx.fillRect(0, 0, startX, H);
  ctx.fillRect(startX+totalW, 0, W-(startX+totalW), H);
  ctx.fillRect(startX, 0, totalW, startY);
  ctx.fillRect(startX, startY+totalH, totalW, H-(startY+totalH));
}

function drawPreviewGrid(ctx, ox, oy, size, scale) {
  const cell = size / 9;
  // Light fill
  ctx.fillStyle = '#fefefe';
  ctx.fillRect(ox, oy, size, size);

  // Sample numbers (sparse)
  const sample = [[0,1,7],[0,4,3],[1,0,9],[2,3,5],[3,6,2],[4,4,8],[5,1,4],[6,7,6],[7,2,1],[8,5,3]];
  ctx.font = `${cell*0.52}px DM Mono, monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#1c1510';
  for (const [r,c,v] of sample) {
    ctx.fillText(String(v), ox + c*cell + cell/2, oy + r*cell + cell/2);
  }
  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';

  // Grid lines
  ctx.strokeStyle = '#1c1510';
  for (let i = 0; i <= 9; i++) {
    ctx.lineWidth = i % 3 === 0 ? 0.8 : 0.2;
    ctx.beginPath(); ctx.moveTo(ox, oy+i*cell); ctx.lineTo(ox+size, oy+i*cell); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ox+i*cell, oy); ctx.lineTo(ox+i*cell, oy+size); ctx.stroke();
  }
}

function drawPreviewNotes(ctx, ox, oy, width, scale) {
  ctx.strokeStyle = 'rgba(180,180,180,0.7)';
  ctx.lineWidth = 0.3;
  const lineGap = 4.5*scale;
  for (let i = 0; i < 3; i++) {
    const ly = oy + 5*scale + i*lineGap;
    ctx.beginPath(); ctx.moveTo(ox, ly); ctx.lineTo(ox+width, ly); ctx.stroke();
  }
}

// Wire preview to all settings changes
document.querySelectorAll('input[type=radio], input[type=number], input[type=text]')
  .forEach(el => el.addEventListener('change', updatePreview));
document.getElementById('countDisplay').addEventListener('input', updatePreview);
document.getElementById('customTitle').addEventListener('input', updatePreview);

// Initial preview after layout settles
setTimeout(updatePreview, 100);
setTimeout(updatePreview, 500);
setTimeout(updatePreview, 1000);
window.addEventListener('resize', updatePreview);
</script>
</body>
</html>
