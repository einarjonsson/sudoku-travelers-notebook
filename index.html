<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TN Sudoku Generator</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=DM+Serif+Display:ital@0;1&family=DM+Mono:wght@400;500&display=swap');
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --ink: #1a1208; --paper: #f5f0e8; --cream: #ede8db;
    --accent: #8b4513; --accent-light: #c4703a; --rule: #c8bfaa;
    --shadow: rgba(26,18,8,0.15); --green: #3a7c52; --green-light: #edf7f1;
    --orange: #c4703a; --orange-light: #fdf3ec;
  }
  body {
    background: var(--paper); color: var(--ink);
    font-family: 'DM Mono', monospace;
    min-height: 100vh; display: flex; flex-direction: column;
    align-items: center; padding: 48px 24px;
    background-image: repeating-linear-gradient(0deg, transparent, transparent 27px, var(--rule) 27px, var(--rule) 28px);
  }
  header { text-align: center; margin-bottom: 48px; }
  .logo { font-family: 'DM Serif Display', serif; font-size: clamp(2rem, 6vw, 3.5rem); line-height: 1.1; margin-bottom: 8px; }
  .logo em { font-style: italic; color: var(--accent); }
  .tagline { font-size: 0.75rem; letter-spacing: 0.15em; text-transform: uppercase; color: var(--accent); opacity: 0.8; }
  .card {
    background: #fffdf7; border: 1.5px solid var(--rule); border-radius: 2px;
    padding: 36px; width: 100%; max-width: 480px;
    box-shadow: 4px 4px 0 var(--shadow); position: relative;
  }
  .card::before {
    content: ''; position: absolute; left: 20px; top: 0; bottom: 0;
    width: 1.5px; background: #e8b4a0; opacity: 0.5;
  }
  .field { margin-bottom: 28px; }
  label {
    display: block; font-size: 0.7rem; letter-spacing: 0.12em;
    text-transform: uppercase; color: var(--accent); margin-bottom: 10px; padding-left: 28px;
  }
  .options { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; padding-left: 28px; }
  .option { cursor: pointer; }
  .option input { display: none; }
  .option-label {
    display: block; border: 1.5px solid var(--rule); border-radius: 2px;
    padding: 12px 14px; font-size: 0.75rem; line-height: 1.4;
    transition: all 0.15s ease; background: var(--cream); cursor: pointer;
  }
  .option-label strong { display: block; font-size: 0.8rem; margin-bottom: 2px; }
  .option input:checked + .option-label { border-color: var(--accent); background: var(--accent); color: var(--paper); }
  .option-label:hover { border-color: var(--accent-light); }
  .count-row { display: flex; align-items: center; gap: 12px; padding-left: 28px; }
  .count-btn {
    width: 36px; height: 36px; border: 1.5px solid var(--rule);
    background: var(--cream); color: var(--ink); font-family: 'DM Mono', monospace;
    font-size: 1.2rem; cursor: pointer; border-radius: 2px; transition: all 0.15s;
    display: flex; align-items: center; justify-content: center; flex-shrink: 0;
  }
  .count-btn:hover { border-color: var(--accent); background: var(--accent); color: white; }
  .count-hint { font-size: 0.65rem; color: var(--accent); opacity: 0.7; line-height: 1.4; }

  /* Duplex banner */
  .duplex-banner {
    margin: 0 0 24px 28px; padding: 10px 14px; border-radius: 2px;
    font-size: 0.7rem; line-height: 1.5; border: 1.5px solid;
    display: flex; align-items: flex-start; gap: 8px;
  }
  .duplex-banner.supported { background: var(--green-light); border-color: var(--green); color: var(--green); }
  .duplex-banner.manual { background: var(--orange-light); border-color: var(--orange); color: var(--orange); }
  .duplex-banner .icon { font-size: 1rem; flex-shrink: 0; margin-top: 1px; }

  .generate-btn {
    width: calc(100% - 28px); margin-left: 28px; padding: 16px;
    background: var(--accent); color: var(--paper); border: none; border-radius: 2px;
    font-family: 'DM Mono', monospace; font-size: 0.8rem; letter-spacing: 0.1em;
    text-transform: uppercase; cursor: pointer; transition: all 0.2s;
    box-shadow: 3px 3px 0 rgba(139,69,19,0.3); margin-top: 8px;
  }
  .generate-btn:hover:not(:disabled) { background: var(--accent-light); transform: translate(-1px,-1px); box-shadow: 4px 4px 0 rgba(139,69,19,0.3); }
  .generate-btn:disabled { opacity: 0.6; cursor: not-allowed; }

  .progress { display: none; padding-left: 28px; margin-top: 20px; }
  .progress.visible { display: block; }
  .progress-bar-track { height: 4px; background: var(--cream); border-radius: 2px; overflow: hidden; margin-bottom: 8px; }
  .progress-bar-fill { height: 100%; background: var(--accent); border-radius: 2px; transition: width 0.3s ease; width: 0%; }
  .progress-text { font-size: 0.65rem; color: var(--accent); letter-spacing: 0.08em; }

  /* Modal */
  .modal-overlay {
    display: none; position: fixed; inset: 0;
    background: rgba(26,18,8,0.55); z-index: 100;
    align-items: center; justify-content: center; padding: 24px;
  }
  .modal-overlay.visible { display: flex; }
  .modal {
    background: #fffdf7; border: 1.5px solid var(--rule); border-radius: 2px;
    padding: 36px; max-width: 440px; width: 100%;
    box-shadow: 6px 6px 0 var(--shadow); position: relative;
  }
  .modal::before {
    content: ''; position: absolute; left: 18px; top: 0; bottom: 0;
    width: 1.5px; background: #e8b4a0; opacity: 0.5;
  }
  .modal-title {
    font-family: 'DM Serif Display', serif; font-size: 1.4rem;
    margin-bottom: 6px; padding-left: 28px;
  }
  .modal-subtitle { font-size: 0.65rem; color: var(--accent); opacity: 0.7; margin-bottom: 24px; padding-left: 28px; letter-spacing: 0.08em; }
  .steps { padding-left: 28px; }
  .step {
    display: flex; gap: 12px; margin-bottom: 16px; align-items: flex-start;
  }
  .step-num {
    width: 24px; height: 24px; border-radius: 50%;
    background: var(--accent); color: white; font-size: 0.7rem;
    display: flex; align-items: center; justify-content: center; flex-shrink: 0;
    margin-top: 1px;
  }
  .step-num.done { background: var(--green); }
  .step-text { font-size: 0.75rem; line-height: 1.5; color: var(--ink); }
  .step-text strong { color: var(--accent); }
  .modal-btn {
    margin-left: 28px; margin-top: 24px; padding: 13px 24px;
    background: var(--accent); color: var(--paper); border: none; border-radius: 2px;
    font-family: 'DM Mono', monospace; font-size: 0.75rem; letter-spacing: 0.1em;
    text-transform: uppercase; cursor: pointer; transition: all 0.15s;
    box-shadow: 3px 3px 0 rgba(139,69,19,0.3);
  }
  .modal-btn:hover { background: var(--accent-light); }
  .modal-btn.secondary {
    background: transparent; color: var(--accent); box-shadow: none;
    border: 1.5px solid var(--rule); margin-left: 8px;
  }
  .modal-btn.secondary:hover { border-color: var(--accent); }

  footer { margin-top: 48px; font-size: 0.65rem; color: var(--accent); opacity: 0.6; text-align: center; letter-spacing: 0.08em; }
  input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
  input[type=number] { -moz-appearance: textfield; }
</style>
</head>
<body>

<header>
  <div class="logo">Traveler's<br><em>Sudoku</em></div>
  <div class="tagline">Printable inserts for your notebook</div>
</header>

<div class="card">
  <div class="field">
    <label>Notebook Size</label>
    <div class="options">
      <label class="option">
        <input type="radio" name="size" value="regular" checked>
        <span class="option-label"><strong>Regular</strong>110mm panels<br>fold + cut</span>
      </label>
      <label class="option">
        <input type="radio" name="size" value="passport">
        <span class="option-label"><strong>Passport</strong>134×98mm<br>cut only</span>
      </label>
    </div>
  </div>

  <div class="field">
    <label>Difficulty</label>
    <div class="options" style="grid-template-columns:1fr 1fr 1fr;">
      <label class="option">
        <input type="radio" name="difficulty" value="easy">
        <span class="option-label"><strong>Easy</strong>more given<br>numbers</span>
      </label>
      <label class="option">
        <input type="radio" name="difficulty" value="medium" checked>
        <span class="option-label"><strong>Medium</strong>balanced<br>challenge</span>
      </label>
      <label class="option">
        <input type="radio" name="difficulty" value="hard">
        <span class="option-label"><strong>Hard</strong>fewer given<br>numbers</span>
      </label>
    </div>
  </div>

  <div class="field">
    <label>Custom Title <span style="opacity:0.5;font-size:0.6rem;text-transform:none;letter-spacing:0">(optional)</span></label>
    <div style="padding-left:28px;">
      <input type="text" id="customTitle" placeholder="e.g. Anna's Sudoku Book"
        style="width:100%;font-family:'DM Mono',monospace;font-size:0.8rem;color:var(--ink);
               border:1.5px solid var(--rule);border-radius:2px;background:var(--cream);
               padding:10px 12px;outline:none;transition:border-color 0.15s;"
        onfocus="this.style.borderColor='var(--accent)'"
        onblur="this.style.borderColor='var(--rule)'"
      >
    </div>
  </div>

  <div class="field">
    <label>Cover Page</label>
    <div class="options" style="padding-left:28px;">
      <label class="option">
        <input type="radio" name="cover" value="none" checked>
        <span class="option-label"><strong>None</strong>no cover<br>page</span>
      </label>
      <label class="option">
        <input type="radio" name="cover" value="cover">
        <span class="option-label"><strong>Cover</strong>elegant frame,<br>title or blank</span>
      </label>
    </div>
  </div>

  <div class="field">
    <label>Font Style</label>
    <div class="options" style="grid-template-columns:1fr 1fr 1fr; padding-left:28px;">
      <label class="option">
        <input type="radio" name="font" value="helvetica" checked>
        <span class="option-label" style="font-family:sans-serif;"><strong>Classic</strong>clean &amp;<br>minimal</span>
      </label>
      <label class="option">
        <input type="radio" name="font" value="times">
        <span class="option-label" style="font-family:serif;"><strong style="font-family:serif;">Serif</strong>traditional<br>newspaper</span>
      </label>
      <label class="option">
        <input type="radio" name="font" value="courier">
        <span class="option-label" style="font-family:monospace;"><strong style="font-family:monospace;">Mono</strong>typewriter<br>style</span>
      </label>
    </div>
  </div>

  <div class="field">
    <label>Notes Section</label>
    <div class="options" style="padding-left:28px;">
      <label class="option">
        <input type="radio" name="notes" value="none" checked>
        <span class="option-label"><strong>None</strong>no notes<br>section</span>
      </label>
      <label class="option">
        <input type="radio" name="notes" value="notes">
        <span class="option-label"><strong>Notes</strong>lined space<br>below puzzle</span>
      </label>
    </div>
  </div>

  <div class="field">
    <label>Puzzle Numbering</label>
    <div class="options" style="grid-template-columns:1fr 1fr 1fr; padding-left:28px;">
      <label class="option">
        <input type="radio" name="numbering" value="sudoku" checked>
        <span class="option-label"><strong>Sudoku 1</strong>default<br>style</span>
      </label>
      <label class="option">
        <input type="radio" name="numbering" value="no">
        <span class="option-label"><strong>No. 1</strong>classic<br>style</span>
      </label>
      <label class="option">
        <input type="radio" name="numbering" value="roman">
        <span class="option-label"><strong>I, II, III</strong>roman<br>numerals</span>
      </label>
    </div>
  </div>

  <div class="field">
    <label>Date Field</label>
    <div class="options" style="padding-left:28px;">
      <label class="option">
        <input type="radio" name="datefield" value="none" checked>
        <span class="option-label"><strong>None</strong>no date<br>field</span>
      </label>
      <label class="option">
        <input type="radio" name="datefield" value="date">
        <span class="option-label"><strong>Date</strong>blank line<br>to fill in</span>
      </label>
    </div>
  </div>

  <div class="field">
    <label>Number of Pages</label>
    <div class="count-row">
      <button class="count-btn" id="decBtn">−</button>
      <input type="number" id="countDisplay" value="1" min="1" max="999"
        style="font-family:'DM Serif Display',serif;font-size:2rem;color:var(--ink);width:70px;text-align:center;border:1.5px solid var(--rule);border-radius:2px;background:var(--cream);padding:4px;">
      <button class="count-btn" id="incBtn">+</button>
      <div class="count-hint" id="countHint">= 8 sudokus</div>
    </div>
  </div>

  <div class="field" style="margin-bottom:16px;">
    <label>Printer</label>
    <div id="duplexBanner" class="duplex-banner manual">
      <span class="icon">⏳</span>
      <span id="duplexText">Checking printer support...</span>
    </div>
  </div>

  <button class="generate-btn" id="generateBtn">Generate PDF</button>

  <div class="progress" id="progress">
    <div class="progress-bar-track"><div class="progress-bar-fill" id="progressFill"></div></div>
    <div class="progress-text" id="progressText">Generating puzzles...</div>
  </div>
</div>

<footer>generates a fresh puzzle every time &nbsp;·&nbsp; print on A4 landscape</footer>

<!-- Manual duplex modal -->
<div class="modal-overlay" id="modalOverlay">
  <div class="modal">
    <div class="modal-title">Two-step printing</div>
    <div class="modal-subtitle" id="modalSubtitle">YOUR PRINTER DOESN'T SUPPORT AUTOMATIC DOUBLE-SIDED PRINTING</div>
    <div class="steps" id="modalSteps"></div>
    <div>
      <button class="modal-btn" id="modalBtn1">Download Side 1</button>
      <button class="modal-btn secondary" id="modalClose">Close</button>
    </div>
  </div>
</div>

<script>
const { jsPDF } = window.jspdf;

let pageCount = 1;
let duplexSupported = false;
let generatedPuzzles = null;
let generatedSize = null;
let generatedPages = null;
let generatedDifficulty = null;
let generatedTitle = null;

const countInput = document.getElementById('countDisplay');
const countHint = document.getElementById('countHint');
const decBtn = document.getElementById('decBtn');
const incBtn = document.getElementById('incBtn');
const generateBtn = document.getElementById('generateBtn');
const progress = document.getElementById('progress');
const progressFill = document.getElementById('progressFill');
const progressText = document.getElementById('progressText');
const duplexBanner = document.getElementById('duplexBanner');
const duplexText = document.getElementById('duplexText');
const modalOverlay = document.getElementById('modalOverlay');
const modalBtn1 = document.getElementById('modalBtn1');
const modalClose = document.getElementById('modalClose');

// ── Duplex detection ──────────────────────────────────────────────────────────
function detectDuplex() {
  // Use the CSS media query approach + navigator hints
  const mm = window.matchMedia('print');
  // Check via navigator.userAgentData or legacy navigator hints
  // We can also use the PrintEvent API where available
  // Realistically, browser APIs don't expose duplex reliably —
  // but we can check via a hidden print iframe and CSS @media
  // Best available: check if matchMedia supports 'duplex' media feature
  const canQuery = window.CSS && CSS.supports('color', 'red');
  
  // Try the newer CSS media feature for duplex
  let supported = false;
  try {
    // This works in some Chromium builds
    supported = window.matchMedia('(duplex: duplex)').matches;
  } catch(e) {}

  // Fallback: check navigator for clues
  if (!supported) {
    const ua = navigator.userAgent.toLowerCase();
    // On most modern desktop browsers, we just can't know for sure
    // so we default to manual with an option to override
    supported = false;
  }

  duplexSupported = supported;
  updateDuplexBanner();
}

function updateDuplexBanner() {
  if (duplexSupported) {
    duplexBanner.className = 'duplex-banner supported';
    duplexBanner.innerHTML = `<span class="icon">✓</span><span>Your printer supports double-sided printing — one PDF will be generated.</span>`;
  } else {
    duplexBanner.className = 'duplex-banner manual';
    duplexBanner.innerHTML = `
      <span class="icon">⚠</span>
      <span>Couldn't confirm duplex support. Two PDFs will be generated — Side 1 first, then Side 2 after reinserting the paper.
      <br><a href="#" id="duplexOverride" style="color:var(--accent);font-size:0.65rem;">My printer does support it →</a></span>`;
    document.getElementById('duplexOverride')?.addEventListener('click', e => {
      e.preventDefault(); duplexSupported = true; updateDuplexBanner();
    });
  }
}

detectDuplex();

// ── UI helpers ────────────────────────────────────────────────────────────────
function getSize() { return document.querySelector('input[name="size"]:checked').value; }
function getDifficulty() { return document.querySelector('input[name="difficulty"]:checked')?.value || 'medium'; }
function getTitle() { return document.getElementById('customTitle')?.value.trim() || ''; }
function getCover() { return document.querySelector('input[name="cover"]:checked')?.value || 'none'; }
function getCoverTitle() { return getCover() === 'cover' ? getTitle() : null; }
function getFont() { return document.querySelector('input[name="font"]:checked')?.value || 'helvetica'; }
function getNotes() { return document.querySelector('input[name="notes"]:checked')?.value || 'none'; }
function getNumbering() { return document.querySelector('input[name="numbering"]:checked')?.value || 'sudoku'; }
function getDateField() { return document.querySelector('input[name="datefield"]:checked')?.value || 'none'; }
function toRoman(n) {
  const vals = [1000,900,500,400,100,90,50,40,10,9,5,4,1];
  const syms = ['M','CM','D','CD','C','XC','L','XL','X','IX','V','IV','I'];
  let result = '';
  for (let i = 0; i < vals.length; i++) { while (n >= vals[i]) { result += syms[i]; n -= vals[i]; } }
  return result;
}
function puzzleLabel(n) {
  const style = getNumbering();
  if (style === 'no') return `No. ${n}`;
  if (style === 'roman') return toRoman(n);
  return `Sudoku ${n}`;
}

function updateHint() {
  pageCount = parseInt(countInput.value) || 1;
  countHint.textContent = `= ${pageCount * 8} sudokus`;
}

document.querySelectorAll('input[name="size"]').forEach(r => r.addEventListener('change', updateHint));
countInput.addEventListener('input', updateHint);
decBtn.addEventListener('click', () => { if (pageCount > 1) { pageCount--; countInput.value = pageCount; updateHint(); } });
incBtn.addEventListener('click', () => { pageCount++; countInput.value = pageCount; updateHint(); });

// ── Sudoku logic ──────────────────────────────────────────────────────────────
function isValid(board, row, col, num) {
  for (let c = 0; c < 9; c++) if (board[row][c] === num) return false;
  for (let r = 0; r < 9; r++) if (board[r][col] === num) return false;
  const br = Math.floor(row/3)*3, bc = Math.floor(col/3)*3;
  for (let r = br; r < br+3; r++) for (let c = bc; c < bc+3; c++) if (board[r][c] === num) return false;
  return true;
}
function shuffle(arr) {
  for (let i = arr.length-1; i > 0; i--) { const j = Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
  return arr;
}
function solve(board) {
  for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) {
    if (board[r][c] === 0) {
      for (const n of shuffle([1,2,3,4,5,6,7,8,9])) {
        if (isValid(board,r,c,n)) { board[r][c]=n; if(solve(board)) return true; board[r][c]=0; }
      }
      return false;
    }
  }
  return true;
}
function generateSudoku(difficulty) {
  const removals = difficulty === "easy" ? 36 : difficulty === "hard" ? 54 : 45;
  const board = Array.from({length:9}, ()=>Array(9).fill(0));
  solve(board);
  const cells = []; for (let r=0;r<9;r++) for (let c=0;c<9;c++) cells.push([r,c]);
  shuffle(cells); for (const [r,c] of cells.slice(0, removals)) board[r][c]=0;
  return board;
}

// ── PDF drawing ───────────────────────────────────────────────────────────────
function drawSudoku(doc, ox, oy, size, puzzle, number, labelFs=3) {
  const cell = size/9;
  doc.setFontSize(labelFs*2.5); doc.setFont(getFont(),'bold'); doc.setTextColor(0,0,0);
  doc.setFillColor(255,255,255);
  const pLabel = puzzleLabel(number);
  doc.rect(ox, oy-labelFs*1.2, doc.getTextWidth(pLabel)+2, labelFs*1.5, 'F');
  doc.text(pLabel, ox+1, oy-labelFs*0.2);
  for (let row=0; row<9; row++) for (let col=0; col<9; col++) {
    const val = puzzle[row][col];
    if (val !== 0) {
      const x=ox+col*cell, y=oy+row*cell;
      doc.setFontSize(cell*1.8); doc.setFont(getFont(),'normal'); doc.setTextColor(0,0,0);
      const tw=doc.getTextWidth(String(val));
      doc.text(String(val), x+(cell-tw)/2, y+cell*0.72);
    }
  }
  doc.setDrawColor(0,0,0);
  for (let i=0; i<=9; i++) {
    doc.setLineWidth(i%3===0?0.5:0.18);
    doc.line(ox, oy+i*cell, ox+size, oy+i*cell);
    doc.line(ox+i*cell, oy, ox+i*cell, oy+size);
  }
}


function drawPageTitle(doc, title, W, H) {
  if (!title) return;
  doc.setFontSize(7);
  doc.setFont(getFont(), 'bold');
  doc.setTextColor(80, 80, 80);
  doc.text(title, W / 2, H - 4, { align: 'center' });
}

function drawCoverPage(doc, title) {
  const W = 297, H = 210;
  const colW = 110;

  // Left panel: blank (nothing drawn)

  // Right panel: frame with title
  const margin = 8;
  const fx = colW + margin, fy = margin;
  const fw = colW - margin*2, fh = H - margin*2;

  // Outer frame
  doc.setDrawColor(80, 80, 80);
  doc.setLineWidth(0.8);
  doc.rect(fx, fy, fw, fh);

  // Inner frame (inset by 3mm)
  doc.setLineWidth(0.25);
  doc.rect(fx + 3, fy + 3, fw - 6, fh - 6);

  // Corner marks
  const cs = 5; // corner mark size
  doc.setLineWidth(0.5);
  for (const [ox, oy, sx, sy] of [
    [fx+3, fy+3, 1, 1], [fx+fw-3, fy+3, -1, 1],
    [fx+3, fy+fh-3, 1, -1], [fx+fw-3, fy+fh-3, -1, -1]
  ]) {
    doc.line(ox, oy, ox + sx*cs, oy);
    doc.line(ox, oy, ox, oy + sy*cs);
  }

  if (title) {
    // Parse Vol. number from title if present, else just show title
    const centerX = fx + fw/2;
    const centerY = fy + fh/2;

    // Main title
    doc.setFont(getFont(), 'bold');
    doc.setTextColor(30, 30, 30);
    doc.setFontSize(11);
    doc.text(title, centerX, centerY - 4, { align: 'center', maxWidth: fw - 16 });

    // Decorative line under title
    const lineW = Math.min(doc.getTextWidth(title) + 8, fw - 20);
    doc.setLineWidth(0.3);
    doc.setDrawColor(120, 120, 120);
    doc.line(centerX - lineW/2, centerY + 1, centerX + lineW/2, centerY + 1);

    // "Sudoku Puzzles" subtitle
    doc.setFont(getFont(), 'normal');
    doc.setFontSize(6);
    doc.setTextColor(100, 100, 100);
    doc.text('SUDOKU PUZZLES', centerX, centerY + 7, { align: 'center' });
  } else {
    // Blank — show subtle writing lines
    const centerY = fy + fh/2;
    doc.setDrawColor(180, 180, 180);
    doc.setLineWidth(0.2);
    for (let i = -1; i <= 1; i++) {
      const ly = centerY + i * 8;
      doc.line(fx + 12, ly, fx + fw - 12, ly);
    }
    // Tiny label above lines
    doc.setFont(getFont(), 'normal');
    doc.setFontSize(5);
    doc.setTextColor(160, 160, 160);
    doc.text('MY SUDOKU BOOK', fx + fw/2, centerY - 14, { align: 'center' });
  }
}

function drawNotes(doc, ox, oy, width) {
  const lineGap = 4.5;
  const labelFs = 2.8;

  // Date field on the right if enabled
  if (getDateField() === 'date') {
    doc.setFont(getFont(), 'normal');
    doc.setFontSize(labelFs * 2.2);
    doc.setTextColor(160, 160, 160);
    const dateLabel = 'Date: ___________';
    const dw = doc.getTextWidth(dateLabel);
    doc.text(dateLabel, ox + width - dw, oy + labelFs);
  }

  // Notes label on the left
  doc.setFont(getFont(), 'normal');
  doc.setFontSize(labelFs * 2.2);
  doc.setTextColor(160, 160, 160);
  doc.text('Notes', ox, oy + labelFs);

  // Ruled lines
  doc.setDrawColor(180, 180, 180);
  doc.setLineWidth(0.15);
  for (let i = 0; i < 3; i++) {
    const ly = oy + labelFs + 2 + i * lineGap;
    doc.line(ox, ly, ox + width, ly);
  }
}

function drawRegularSide(doc, puzzles, startIdx, sideLabel) {
  const W=297, H=210, colW=110, margin=5, halfH=H/2;
  const notesH = getNotes() === 'notes' ? 18 : 0;
  const sudSize=Math.min(colW-2*margin, halfH-14-notesH), vGap=(halfH-sudSize-notesH)/2;
  for (const [col,row,num] of [[0,0,startIdx],[0,1,startIdx+1],[1,0,startIdx+2],[1,1,startIdx+3]]) {
    const ox = col*colW+margin, oy = row*halfH+vGap;
    drawSudoku(doc, ox, oy, sudSize, puzzles[num-1], num, 3);
    if (getNotes() === 'notes') drawNotes(doc, ox, oy + sudSize + 3, sudSize);
  }
  doc.setDrawColor(100,100,100); doc.setLineWidth(0.25);
  doc.setLineDashPattern([2,1.5],0); doc.line(colW,0,colW,H);
  doc.setLineDashPattern([0.8,2],0); doc.setDrawColor(80,80,80); doc.line(2*colW,0,2*colW,H);
  doc.setLineDashPattern([],0);
  doc.setDrawColor(180,180,180); doc.setLineWidth(0.12); doc.setLineDashPattern([1,2],0);
  doc.line(0,halfH,2*colW,halfH); doc.setLineDashPattern([],0);
  doc.setFontSize(4); doc.setFont(getFont(),'normal'); doc.setTextColor(120,120,120);
  doc.text('--- fold at 110mm', 2*colW+2, halfH-4);
  doc.text('... cut at 220mm', 2*colW+2, halfH);
  doc.text(sideLabel, 2*colW+2, halfH+4);
  drawPageTitle(doc, getTitle(), W, H);
}

function drawPassportSide(doc, puzzles, startIdx, sideLabel) {
  const W=297, H=210, pw=134, ph=98;
  const totalW=pw*2, totalH=ph*2;
  const startX=(W-totalW)/2, startY=(H-totalH)/2;
  const passNotesH = getNotes() === 'notes' ? 14 : 0;
  const labelH=8, gridSize=Math.min(pw-8,ph-8-labelH-passNotesH);
  const vOff=(ph-gridSize-labelH-passNotesH)/2, hOff=(pw-gridSize)/2;
  for (const [col,row,num] of [[0,0,startIdx],[1,0,startIdx+1],[0,1,startIdx+2],[1,1,startIdx+3]]) {
    const ox = startX+col*pw+hOff, oy = startY+row*ph+vOff;
    drawSudoku(doc, ox, oy, gridSize, puzzles[num-1], num, 2.5);
    if (getNotes() === 'notes') drawNotes(doc, ox, oy + gridSize + 2, gridSize);
  }
  doc.setDrawColor(160,160,160); doc.setLineWidth(0.15); doc.setLineDashPattern([],0);
  for (let col=0;col<2;col++) for (let row=0;row<2;row++) doc.rect(startX+col*pw, startY+row*ph, pw, ph);
  doc.setDrawColor(80,80,80); doc.setLineWidth(0.25); doc.setLineDashPattern([0.8,2],0);
  doc.line(startX+pw, startY-4, startX+pw, startY+totalH+4);
  doc.line(startX-4, startY+ph, startX+totalW+4, startY+ph);
  doc.setLineDashPattern([],0);
  doc.setFontSize(4); doc.setFont(getFont(),'normal'); doc.setTextColor(120,120,120);
  doc.text('... cut horizontally and vertically at centre | '+sideLabel, W/2, startY-4, {align:'center'});
  drawPageTitle(doc, getTitle(), W, H);
}

// ── Build PDFs ────────────────────────────────────────────────────────────────
function buildDoc(puzzles, size, pages, sideFilter) {
  // sideFilter: 'all' | 'side1' | 'side2'
  // For side2 manual duplex: pages must be in REVERSE order so when
  // the stack is flipped, page N back aligns with page N front.
  const doc = new jsPDF({ orientation:'landscape', unit:'mm', format:'a4' });
  let first = true;

  // Dedicated cover sheet: blank left panel, framed right panel
  // Printed as first page of side1 so when folded = outside front cover
  if (getCover() === 'cover' && sideFilter !== 'side2') {
    drawCoverPage(doc, getTitle());
    first = false;
  }

  const pageOrder = sideFilter === 'side2'
    ? Array.from({length:pages}, (_,i) => pages-1-i)  // reversed
    : Array.from({length:pages}, (_,i) => i);

  for (const p of pageOrder) {
    const base = p * 8;
    if (sideFilter === 'all' || sideFilter === 'side1') {
      if (!first) doc.addPage(); first = false;
      const label = `Page ${p+1} of ${pages} - Side 1`;
      size === 'regular'
        ? drawRegularSide(doc, puzzles, base+1, label)
        : drawPassportSide(doc, puzzles, base+1, label);
    }
    if (sideFilter === 'all' || sideFilter === 'side2') {
      if (!first) doc.addPage(); first = false;
      const label = `Page ${p+1} of ${pages} - Side 2`;
      size === 'regular'
        ? drawRegularSide(doc, puzzles, base+5, label)
        : drawPassportSide(doc, puzzles, base+5, label);
    }
  }
  return doc;
}

// ── Generate button ───────────────────────────────────────────────────────────
generateBtn.addEventListener('click', async () => {
  const size = getSize();
  const pages = parseInt(countInput.value) || 1;
  const total = pages * 8;

  generateBtn.disabled = true;
  progress.classList.add('visible');

  await new Promise(r => setTimeout(r, 50));

  const puzzles = [];
  for (let i=0; i<total; i++) {
    setProgress(i/total*60, `Generating puzzle ${i+1} of ${total}...`);
    await new Promise(r => setTimeout(r, 0));
    puzzles.push(generateSudoku(getDifficulty()));
  }

  setProgress(80, 'Building PDF...');
  await new Promise(r => setTimeout(r, 50));

  if (duplexSupported) {
    // Single PDF, all pages interleaved
    const doc = buildDoc(puzzles, size, pages, 'all');
    setProgress(100, 'Done! Downloading...');
    await new Promise(r => setTimeout(r, 300));
    const titleSlug = getTitle().replace(/[^a-z0-9]/gi,'-').toLowerCase().replace(/-+/g,'-').replace(/^-|-$/g,'');
    const fname = titleSlug ? `${titleSlug}-sudoku-${size}-${getDifficulty()}-${pages}pages.pdf` : `tn-sudoku-${size}-${getDifficulty()}-${pages}pages.pdf`;
    doc.save(fname);
    generateBtn.disabled = false;
    progress.classList.remove('visible');
    progressFill.style.width = '0%';
  } else {
    // Store puzzles and show modal
    generatedPuzzles = puzzles;
    generatedSize = size;
    generatedPages = pages;
    generatedDifficulty = getDifficulty();
    generatedTitle = getTitle();
    setProgress(100, 'Ready!');
    await new Promise(r => setTimeout(r, 300));
    generateBtn.disabled = false;
    progress.classList.remove('visible');
    progressFill.style.width = '0%';
    showManualModal(size, pages);
  }
});

// ── Manual duplex modal ───────────────────────────────────────────────────────
function showManualModal(size, pages) {
  document.getElementById('modalSteps').innerHTML = `
    <div class="step">
      <div class="step-num">1</div>
      <div class="step-text">Click <strong>Download Side 1</strong> and print it on your printer. Make sure to print in <strong>landscape</strong> orientation.</div>
    </div>
    <div class="step">
      <div class="step-num">2</div>
      <div class="step-text">Take the printed pages out of the tray. <strong>Flip the stack face-down</strong> and reinsert it into the paper feed — do not rotate it.</div>
    </div>
    <div class="step">
      <div class="step-num">3</div>
      <div class="step-text">Click <strong>Download Side 2</strong> and print it. The pages are already in reverse order so they line up correctly when flipped.</div>
    </div>
  `;

  modalBtn1.textContent = 'Download Side 1';
  modalBtn1.onclick = () => {
    const doc = buildDoc(generatedPuzzles, generatedSize, generatedPages, 'side1');
    doc.save(`tn-sudoku-${generatedSize}-${generatedDifficulty}-side1.pdf`);
    // After download, update modal to step 2/3
    modalBtn1.textContent = 'Download Side 2';
    modalBtn1.onclick = () => {
      const doc2 = buildDoc(generatedPuzzles, generatedSize, generatedPages, 'side2');
      doc2.save(`tn-sudoku-${generatedSize}-${generatedDifficulty}-side2.pdf`);
      modalBtn1.textContent = '✓ All done!';
      modalBtn1.disabled = true;
      // Mark steps done
      document.querySelectorAll('.step-num').forEach(el => { el.classList.add('done'); el.textContent = '✓'; });
    };
    // Mark step 1 done
    const steps = document.querySelectorAll('.step-num');
    steps[0].classList.add('done'); steps[0].textContent = '✓';
  };

  modalOverlay.classList.add('visible');
}

modalClose.addEventListener('click', () => modalOverlay.classList.remove('visible'));
modalOverlay.addEventListener('click', e => { if (e.target === modalOverlay) modalOverlay.classList.remove('visible'); });

function setProgress(pct, text) {
  progressFill.style.width = pct+'%';
  progressText.textContent = text;
}

updateHint();
</script>
</body>
</html>
